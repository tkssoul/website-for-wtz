"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  SubscriberFlags: () => SubscriberFlags,
  computed: () => computed,
  createReactiveSystem: () => createReactiveSystem,
  effect: () => effect,
  effectScope: () => effectScope,
  endBatch: () => endBatch,
  pauseTracking: () => pauseTracking,
  resumeTracking: () => resumeTracking,
  signal: () => signal,
  startBatch: () => startBatch
});
module.exports = __toCommonJS(src_exports);

// src/system.ts
var SubscriberFlags = /* @__PURE__ */ ((SubscriberFlags2) => {
  SubscriberFlags2[SubscriberFlags2["Computed"] = 1] = "Computed";
  SubscriberFlags2[SubscriberFlags2["Effect"] = 2] = "Effect";
  SubscriberFlags2[SubscriberFlags2["Tracking"] = 4] = "Tracking";
  SubscriberFlags2[SubscriberFlags2["Notified"] = 8] = "Notified";
  SubscriberFlags2[SubscriberFlags2["Recursed"] = 16] = "Recursed";
  SubscriberFlags2[SubscriberFlags2["Dirty"] = 32] = "Dirty";
  SubscriberFlags2[SubscriberFlags2["PendingComputed"] = 64] = "PendingComputed";
  SubscriberFlags2[SubscriberFlags2["PendingEffect"] = 128] = "PendingEffect";
  SubscriberFlags2[SubscriberFlags2["Propagated"] = 224] = "Propagated";
  return SubscriberFlags2;
})(SubscriberFlags || {});
function createReactiveSystem({
  updateComputed,
  notifyEffect: notifyEffect2
}) {
  let queuedEffects;
  let queuedEffectsTail;
  return {
    /**
     * Links a given dependency and subscriber if they are not already linked.
     * 
     * @param dep - The dependency to be linked.
     * @param sub - The subscriber that depends on this dependency.
     * @returns The newly created link object if the two are not already linked; otherwise `undefined`.
     */
    link(dep, sub) {
      const currentDep = sub.depsTail;
      if (currentDep !== void 0 && currentDep.dep === dep) {
        return;
      }
      const nextDep = currentDep !== void 0 ? currentDep.nextDep : sub.deps;
      if (nextDep !== void 0 && nextDep.dep === dep) {
        sub.depsTail = nextDep;
        return;
      }
      const depLastSub = dep.subsTail;
      if (depLastSub !== void 0 && depLastSub.sub === sub && isValidLink(depLastSub, sub)) {
        return;
      }
      return linkNewDep(dep, sub, nextDep, currentDep);
    },
    /**
     * Traverses and marks subscribers starting from the provided link.
     * 
     * It sets flags (e.g., Dirty, PendingComputed, PendingEffect) on each subscriber
     * to indicate which ones require re-computation or effect processing. 
     * This function should be called after a signal's value changes.
     * 
     * @param link - The starting link from which propagation begins.
     */
    propagate(link2) {
      let targetFlag = 32 /* Dirty */;
      let subs = link2;
      let stack = 0;
      top: do {
        const sub = link2.sub;
        const subFlags = sub.flags;
        if (!(subFlags & (4 /* Tracking */ | 16 /* Recursed */ | 224 /* Propagated */)) && (sub.flags = subFlags | targetFlag | 8 /* Notified */, true) || subFlags & 16 /* Recursed */ && !(subFlags & 4 /* Tracking */) && (sub.flags = subFlags & ~16 /* Recursed */ | targetFlag | 8 /* Notified */, true) || !(subFlags & 224 /* Propagated */) && isValidLink(link2, sub) && (sub.flags = subFlags | 16 /* Recursed */ | targetFlag | 8 /* Notified */, sub.subs !== void 0)) {
          const subSubs = sub.subs;
          if (subSubs !== void 0) {
            if (subSubs.nextSub !== void 0) {
              subSubs.prevSub = subs;
              link2 = subs = subSubs;
              targetFlag = 64 /* PendingComputed */;
              ++stack;
            } else {
              link2 = subSubs;
              targetFlag = subFlags & 2 /* Effect */ ? 128 /* PendingEffect */ : 64 /* PendingComputed */;
            }
            continue;
          }
          if (subFlags & 2 /* Effect */) {
            if (queuedEffectsTail !== void 0) {
              queuedEffectsTail.depsTail.nextDep = sub.deps;
            } else {
              queuedEffects = sub;
            }
            queuedEffectsTail = sub;
          }
        } else if (!(subFlags & (4 /* Tracking */ | targetFlag))) {
          sub.flags = subFlags | targetFlag | 8 /* Notified */;
          if ((subFlags & (2 /* Effect */ | 8 /* Notified */)) === 2 /* Effect */) {
            if (queuedEffectsTail !== void 0) {
              queuedEffectsTail.depsTail.nextDep = sub.deps;
            } else {
              queuedEffects = sub;
            }
            queuedEffectsTail = sub;
          }
        } else if (!(subFlags & targetFlag) && subFlags & 224 /* Propagated */ && isValidLink(link2, sub)) {
          sub.flags = subFlags | targetFlag;
        }
        if ((link2 = subs.nextSub) !== void 0) {
          subs = link2;
          targetFlag = stack ? 64 /* PendingComputed */ : 32 /* Dirty */;
          continue;
        }
        while (stack) {
          --stack;
          const dep = subs.dep;
          const depSubs = dep.subs;
          subs = depSubs.prevSub;
          depSubs.prevSub = void 0;
          if ((link2 = subs.nextSub) !== void 0) {
            subs = link2;
            targetFlag = stack ? 64 /* PendingComputed */ : 32 /* Dirty */;
            continue top;
          }
        }
        break;
      } while (true);
    },
    /**
     * Prepares the given subscriber to track new dependencies.
     * 
     * It resets the subscriber's internal pointers (e.g., depsTail) and
     * sets its flags to indicate it is now tracking dependency links.
     * 
     * @param sub - The subscriber to start tracking.
     */
    startTracking(sub) {
      sub.depsTail = void 0;
      sub.flags = sub.flags & ~(8 /* Notified */ | 16 /* Recursed */ | 224 /* Propagated */) | 4 /* Tracking */;
    },
    /**
     * Concludes tracking of dependencies for the specified subscriber.
     * 
     * It clears or unlinks any tracked dependency information, then
     * updates the subscriber's flags to indicate tracking is complete.
     * 
     * @param sub - The subscriber whose tracking is ending.
     */
    endTracking(sub) {
      const depsTail = sub.depsTail;
      if (depsTail !== void 0) {
        const nextDep = depsTail.nextDep;
        if (nextDep !== void 0) {
          clearTracking(nextDep);
          depsTail.nextDep = void 0;
        }
      } else if (sub.deps !== void 0) {
        clearTracking(sub.deps);
        sub.deps = void 0;
      }
      sub.flags &= ~4 /* Tracking */;
    },
    /**
     * Updates the dirty flag for the given subscriber based on its dependencies.
     * 
     * If the subscriber has any pending computeds, this function sets the Dirty flag
     * and returns `true`. Otherwise, it clears the PendingComputed flag and returns `false`.
     * 
     * @param sub - The subscriber to update.
     * @param flags - The current flag set for this subscriber.
     * @returns `true` if the subscriber is marked as Dirty; otherwise `false`.
     */
    updateDirtyFlag(sub, flags) {
      if (checkDirty(sub.deps)) {
        sub.flags = flags | 32 /* Dirty */;
        return true;
      } else {
        sub.flags = flags & ~64 /* PendingComputed */;
        return false;
      }
    },
    /**
     * Updates the computed subscriber if necessary before its value is accessed.
     * 
     * If the subscriber is marked Dirty or PendingComputed, this function runs
     * the provided updateComputed logic and triggers a shallowPropagate for any
     * downstream subscribers if an actual update occurs.
     * 
     * @param computed - The computed subscriber to update.
     * @param flags - The current flag set for this subscriber.
     */
    processComputedUpdate(computed2, flags) {
      if (flags & 32 /* Dirty */ || (checkDirty(computed2.deps) ? true : (computed2.flags = flags & ~64 /* PendingComputed */, false))) {
        if (updateComputed(computed2)) {
          const subs = computed2.subs;
          if (subs !== void 0) {
            shallowPropagate(subs);
          }
        }
      }
    },
    /**
     * Ensures all pending internal effects for the given subscriber are processed.
     * 
     * This should be called after an effect decides not to re-run itself but may still
     * have dependencies flagged with PendingEffect. If the subscriber is flagged with
     * PendingEffect, this function clears that flag and invokes `notifyEffect` on any
     * related dependencies marked as Effect and Propagated, processing pending effects.
     * 
     * @param sub - The subscriber which may have pending effects.
     * @param flags - The current flags on the subscriber to check.
     */
    processPendingInnerEffects(sub, flags) {
      if (flags & 128 /* PendingEffect */) {
        sub.flags = flags & ~128 /* PendingEffect */;
        let link2 = sub.deps;
        do {
          const dep = link2.dep;
          if ("flags" in dep && dep.flags & 2 /* Effect */ && dep.flags & 224 /* Propagated */) {
            notifyEffect2(dep);
          }
          link2 = link2.nextDep;
        } while (link2 !== void 0);
      }
    },
    /**
     * Processes queued effect notifications after a batch operation finishes.
     * 
     * Iterates through all queued effects, calling notifyEffect on each.
     * If an effect remains partially handled, its flags are updated, and future
     * notifications may be triggered until fully handled.
     */
    processEffectNotifications() {
      while (queuedEffects !== void 0) {
        const effect2 = queuedEffects;
        const depsTail = effect2.depsTail;
        const queuedNext = depsTail.nextDep;
        if (queuedNext !== void 0) {
          depsTail.nextDep = void 0;
          queuedEffects = queuedNext.sub;
        } else {
          queuedEffects = void 0;
          queuedEffectsTail = void 0;
        }
        if (!notifyEffect2(effect2)) {
          effect2.flags &= ~8 /* Notified */;
        }
      }
    }
  };
  function linkNewDep(dep, sub, nextDep, depsTail) {
    const newLink = {
      dep,
      sub,
      nextDep,
      prevSub: void 0,
      nextSub: void 0
    };
    if (depsTail === void 0) {
      sub.deps = newLink;
    } else {
      depsTail.nextDep = newLink;
    }
    if (dep.subs === void 0) {
      dep.subs = newLink;
    } else {
      const oldTail = dep.subsTail;
      newLink.prevSub = oldTail;
      oldTail.nextSub = newLink;
    }
    sub.depsTail = newLink;
    dep.subsTail = newLink;
    return newLink;
  }
  function checkDirty(link2) {
    let stack = 0;
    let dirty;
    top: do {
      dirty = false;
      const dep = link2.dep;
      if ("flags" in dep) {
        const depFlags = dep.flags;
        if ((depFlags & (1 /* Computed */ | 32 /* Dirty */)) === (1 /* Computed */ | 32 /* Dirty */)) {
          if (updateComputed(dep)) {
            const subs = dep.subs;
            if (subs.nextSub !== void 0) {
              shallowPropagate(subs);
            }
            dirty = true;
          }
        } else if ((depFlags & (1 /* Computed */ | 64 /* PendingComputed */)) === (1 /* Computed */ | 64 /* PendingComputed */)) {
          const depSubs = dep.subs;
          if (depSubs.nextSub !== void 0) {
            depSubs.prevSub = link2;
          }
          link2 = dep.deps;
          ++stack;
          continue;
        }
      }
      if (!dirty && link2.nextDep !== void 0) {
        link2 = link2.nextDep;
        continue;
      }
      if (stack) {
        let sub = link2.sub;
        do {
          --stack;
          const subSubs = sub.subs;
          if (dirty) {
            if (updateComputed(sub)) {
              if ((link2 = subSubs.prevSub) !== void 0) {
                subSubs.prevSub = void 0;
                shallowPropagate(sub.subs);
                sub = link2.sub;
              } else {
                sub = subSubs.sub;
              }
              continue;
            }
          } else {
            sub.flags &= ~64 /* PendingComputed */;
          }
          if ((link2 = subSubs.prevSub) !== void 0) {
            subSubs.prevSub = void 0;
            if (link2.nextDep !== void 0) {
              link2 = link2.nextDep;
              continue top;
            }
            sub = link2.sub;
          } else {
            if ((link2 = subSubs.nextDep) !== void 0) {
              continue top;
            }
            sub = subSubs.sub;
          }
          dirty = false;
        } while (stack);
      }
      return dirty;
    } while (true);
  }
  function shallowPropagate(link2) {
    do {
      const sub = link2.sub;
      const subFlags = sub.flags;
      if ((subFlags & (64 /* PendingComputed */ | 32 /* Dirty */)) === 64 /* PendingComputed */) {
        sub.flags = subFlags | 32 /* Dirty */ | 8 /* Notified */;
        if ((subFlags & (2 /* Effect */ | 8 /* Notified */)) === 2 /* Effect */) {
          if (queuedEffectsTail !== void 0) {
            queuedEffectsTail.depsTail.nextDep = sub.deps;
          } else {
            queuedEffects = sub;
          }
          queuedEffectsTail = sub;
        }
      }
      link2 = link2.nextSub;
    } while (link2 !== void 0);
  }
  function isValidLink(checkLink, sub) {
    const depsTail = sub.depsTail;
    if (depsTail !== void 0) {
      let link2 = sub.deps;
      do {
        if (link2 === checkLink) {
          return true;
        }
        if (link2 === depsTail) {
          break;
        }
        link2 = link2.nextDep;
      } while (link2 !== void 0);
    }
    return false;
  }
  function clearTracking(link2) {
    do {
      const dep = link2.dep;
      const nextDep = link2.nextDep;
      const nextSub = link2.nextSub;
      const prevSub = link2.prevSub;
      if (nextSub !== void 0) {
        nextSub.prevSub = prevSub;
      } else {
        dep.subsTail = prevSub;
      }
      if (prevSub !== void 0) {
        prevSub.nextSub = nextSub;
      } else {
        dep.subs = nextSub;
      }
      if (dep.subs === void 0 && "deps" in dep) {
        const depFlags = dep.flags;
        if (!(depFlags & 32 /* Dirty */)) {
          dep.flags = depFlags | 32 /* Dirty */;
        }
        const depDeps = dep.deps;
        if (depDeps !== void 0) {
          link2 = depDeps;
          dep.depsTail.nextDep = nextDep;
          dep.deps = void 0;
          dep.depsTail = void 0;
          continue;
        }
      }
      link2 = nextDep;
    } while (link2 !== void 0);
  }
}

// src/index.ts
var {
  link,
  propagate,
  updateDirtyFlag,
  startTracking,
  endTracking,
  processEffectNotifications,
  processComputedUpdate,
  processPendingInnerEffects
} = createReactiveSystem({
  updateComputed(computed2) {
    const prevSub = activeSub;
    activeSub = computed2;
    startTracking(computed2);
    try {
      const oldValue = computed2.currentValue;
      const newValue = computed2.getter(oldValue);
      if (oldValue !== newValue) {
        computed2.currentValue = newValue;
        return true;
      }
      return false;
    } finally {
      activeSub = prevSub;
      endTracking(computed2);
    }
  },
  notifyEffect(e) {
    if ("isScope" in e) {
      return notifyEffectScope(e);
    } else {
      return notifyEffect(e);
    }
  }
});
var pauseStack = [];
var batchDepth = 0;
var activeSub;
var activeScope;
function startBatch() {
  ++batchDepth;
}
function endBatch() {
  if (!--batchDepth) {
    processEffectNotifications();
  }
}
function pauseTracking() {
  pauseStack.push(activeSub);
  activeSub = void 0;
}
function resumeTracking() {
  activeSub = pauseStack.pop();
}
function signal(oldValue) {
  return signalGetterSetter.bind({
    currentValue: oldValue,
    subs: void 0,
    subsTail: void 0
  });
}
function computed(getter) {
  return computedGetter.bind({
    currentValue: void 0,
    subs: void 0,
    subsTail: void 0,
    deps: void 0,
    depsTail: void 0,
    flags: 1 /* Computed */ | 32 /* Dirty */,
    getter
  });
}
function effect(fn) {
  const e = {
    fn,
    subs: void 0,
    subsTail: void 0,
    deps: void 0,
    depsTail: void 0,
    flags: 2 /* Effect */
  };
  if (activeSub !== void 0) {
    link(e, activeSub);
  } else if (activeScope !== void 0) {
    link(e, activeScope);
  }
  runEffect(e);
  return effectStop.bind(e);
}
function effectScope(fn) {
  const e = {
    deps: void 0,
    depsTail: void 0,
    flags: 2 /* Effect */,
    isScope: true
  };
  runEffectScope(e, fn);
  return effectStop.bind(e);
}
function runEffect(e) {
  const prevSub = activeSub;
  activeSub = e;
  startTracking(e);
  try {
    e.fn();
  } finally {
    activeSub = prevSub;
    endTracking(e);
  }
}
function runEffectScope(e, fn) {
  const prevSub = activeScope;
  activeScope = e;
  startTracking(e);
  try {
    fn();
  } finally {
    activeScope = prevSub;
    endTracking(e);
  }
}
function notifyEffect(e) {
  const flags = e.flags;
  if (flags & 32 /* Dirty */ || flags & 64 /* PendingComputed */ && updateDirtyFlag(e, flags)) {
    runEffect(e);
  } else {
    processPendingInnerEffects(e, e.flags);
  }
  return true;
}
function notifyEffectScope(e) {
  const flags = e.flags;
  if (flags & 128 /* PendingEffect */) {
    processPendingInnerEffects(e, e.flags);
    return true;
  }
  return false;
}
function computedGetter() {
  const flags = this.flags;
  if (flags & (32 /* Dirty */ | 64 /* PendingComputed */)) {
    processComputedUpdate(this, flags);
  }
  if (activeSub !== void 0) {
    link(this, activeSub);
  } else if (activeScope !== void 0) {
    link(this, activeScope);
  }
  return this.currentValue;
}
function signalGetterSetter(...value) {
  if (value.length) {
    if (this.currentValue !== (this.currentValue = value[0])) {
      const subs = this.subs;
      if (subs !== void 0) {
        propagate(subs);
        if (!batchDepth) {
          processEffectNotifications();
        }
      }
    }
  } else {
    if (activeSub !== void 0) {
      link(this, activeSub);
    }
    return this.currentValue;
  }
}
function effectStop() {
  startTracking(this);
  endTracking(this);
}
